---
title: 算法复杂度
date: 2025-12-25 21:25:02
permalink: /web/algorithm/complexity
categories:
  - 数据结构与算法
tags:
  - 算法、算法复杂度
---

### 时间复杂度与空间复杂度

复杂度分析是整个算法学习的精髓。
- 时间复杂度: 一个算法执行所耗费的时间。
- 空间复杂度: 运行完一个程序所需内存的大小。

学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。​分析一个排序算法，要从 `执行效率`、`内存消耗`、`稳定性` 三方面入手

### 时间复杂度（Time Complexity）
时间复杂度用于分析算法的执行效率。常见的时间复杂度有以下几种：
- 常数时间复杂度：O(1)
- 线性时间复杂度：O(n)
- 对数时间复杂度：O(log n)
- O(n log n)
- 平方时间复杂度：O(n^2)
- 指数时间复杂度：O(2^n)

```javascript
// O(1) - 常数时间
function constantTimeExample(arr: number[]): number {
    return arr[0]; // 只访问数组的第一个元素
}
// O(n) - 线性时间
function linearTimeExample(arr: number[]): void {
    for (let i = 0; i < arr.length; i++) {
        console.log(arr[i]);
    }
}

// O(n^2) - 平方时间
function quadraticTimeExample(matrix: number[][]): void {
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
            console.log(matrix[i][j]);
        }
    }
}

// O(log n) - 对数时间
function logarithmicTimeExample(n: number): void {
    while (n > 1) {
        console.log(n);
        n = Math.floor(n / 2); // 每次将 n 减少一半​  
    }
}

// O(n log n) - 线性对数时间
function linearLogarithmicTimeExample(arr: number[]): number[] {
    if (arr.length <= 1) {
        return arr;
    }
    const mid = Math.floor(arr.length / 2);
    const left = linearLogarithmicTimeExample(arr.slice(0, mid)); // 递归处理左半部分​  
    const right = linearLogarithmicTimeExample(arr.slice(mid)); // 递归处理右半部分​​ 
    return merge(left, right); // 合并两个已排序的数组
}
function merge(left: number[], right: number[]): number[] {
    let result: number[] = []; let i = 0, j = 0;
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
            result.push(left[i]); i++;

        } else {
            result.push(right[j]); j++;
        }
    }
    return result.concat(left.slice(i)).concat(right.slice(j));
}​​
```